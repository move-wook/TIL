# 데이터베이스 시스템의 동시성 제어

## 📌 시야: 동시성 제어는 왜 필요한가?

동시성 제어는 **다수의 트랜잭션이 동시에 실행될 때, 데이터의 정합성과 일관성을 보장하기 위한 메커니즘**이다.

### 동시성 미제어 시 발생할 수 있는 문제

| 문제 유형 | 설명 |
|-----------|------|
| **Lost Update** | 두 트랜잭션이 같은 데이터를 동시에 수정 → 한 트랜잭션의 결과가 덮어써짐 |
| **Dirty Read** | 다른 트랜잭션의 커밋되지 않은 데이터를 읽음 |
| **Non-repeatable Read** | 같은 쿼리를 반복해도 결과가 다름 |
| **Phantom Read** | `WHERE` 조건에 맞는 행의 개수가 달라짐 |

---

## 🔄 루프: 동시성 제어 방식

### 1. Lock 기반 제어 (2PL: Two-Phase Locking)

- **공유 락 (Shared Lock, S Lock)**: 읽기 용도로 사용, 여러 트랜잭션 동시 접근 가능
- **베타 락 (Exclusive Lock, X Lock)**: 쓰기 용도로 사용, 단독 접근만 허용
- **2단계 프로토콜**: 락을 획득하는 단계 → 해제하는 단계로 나뉨

📌 *단점*: Deadlock 발생 가능

---

### 2. MVCC (Multi-Version Concurrency Control)

- 데이터 수정 시 새로운 버전을 생성하여, 트랜잭션마다 자신만의 스냅샷 사용
- 읽기 작업은 락 없이도 가능 (non-blocking read)

📌 *사용 DB*: PostgreSQL, MySQL(InnoDB), Oracle 등  
📌 *단점*: 오래된 버전 정리를 위한 Garbage Collection 필요

---

### 3. 타임스탬프 기반 제어

- 각 트랜잭션에 고유한 타임스탬프를 부여
- 타임스탬프 순서에 따라 충돌 여부 판단

📌 *장점*: Deadlock 없음  
📌 *단점*: 직렬화 불가능 시 트랜잭션 중단

---

### 4. 낙관적 제어 (OCC: Optimistic Concurrency Control)

- 충돌이 거의 없다고 가정
- 단계: 읽기 → 작업 → 검증 → 커밋
- 검증 단계에서 충돌 감지 시 롤백

📌 *장점*: 높은 병행성  
📌 *단점*: 충돌이 많으면 비효율적

---

## ⚖ 기준 형성: 어떤 방식을 선택할 것인가?

| 기준 | 추천 방식 |
|------|-----------|
| 읽기 작업 위주 | MVCC |
| 충돌 가능성 높음 | 2PL (Lock 기반) |
| Deadlock 회피 우선 | 타임스탬프 기반 or OCC |
| 성능과 정합성 균형 | MVCC + Repeatable Read |

---

## 🔭 시야 전이: 트랜잭션 격리 수준과의 연결

트랜잭션 격리 수준은 동시성 제어 방식과 함께 **정합성과 성능 사이의 밸런스를 맞추는 중요한 요소**이다.

| 격리 수준 (Isolation Level) | 허용되는 현상 | 설명 |
|-----------------------------|----------------|------|
| READ UNCOMMITTED | Dirty Read | 가장 낮은 수준, 정합성 약함 |
| READ COMMITTED | Non-repeatable Read | Oracle 기본 |
| REPEATABLE READ | Phantom Read | MySQL 기본 |
| SERIALIZABLE | 없음 | 가장 강력, 가장 느림 |

---

## 🧩 결론 요약

- 동시성 제어는 데이터 손상을 막기 위한 핵심 메커니즘
- Lock, MVCC, OCC, 타임스탬프 기반 등 다양한 방식 존재
- 트랜잭션 격리 수준과 함께 고려해야 최적의 일관성/성능 확보 가능
- 상황에 따라 **읽기/쓰기 패턴**, **충돌 빈도**, **데이터베이스 종류**를 고려해 적절한 전략을 설계해야 함

---
