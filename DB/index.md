# 📘 데이터베이스 인덱스 개념과 설계 기준

## 🔍 인덱스란?

- **정의**: 데이터베이스 테이블의 **검색 속도**를 향상시키기 위한 **자료구조**
- **비유**: 백과사전의 색인과 같음
- **특징**: 항상 정렬된 상태로 유지되며, INSERT/UPDATE/DELETE 시 성능 희생이 발생

---

## 🌲 인덱스의 자료구조 - B+Tree (MySQL InnoDB 기준)

### 📌 B+Tree 구조 요약

- **루트 노드** → **브랜치 노드** → **리프 노드**
- **리프 노드**에는 **PK 또는 레코드 주소**가 저장됨
- **세컨더리 인덱스**는 리프 노드에 **프라이머리 키**가 저장됨  
  → PK로 다시 한번 테이블을 검색해야 함 (더블 조회)

---

## 🚦 인덱스 스캔 방식 (MySQL)

| 스캔 방식 | 설명 |
|-----------|------|
| **인덱스 레인지 스캔** | 범위 조건이 명확한 경우 사용. 빠르고 효율적 |
| **인덱스 풀 스캔** | 인덱스를 처음부터 끝까지 순회. 조건절에 인덱스 일부만 사용하는 경우 |
| **루스 인덱스 스캔** | 중간 값은 건너뛰며 듬성듬성 읽음. `GROUP BY`, `MIN()`, `MAX()`에 최적화 |

---

## 🎯 인덱스 설계 시 고려해야 할 기준

| 기준 항목 | 설명 |
|-----------|------|
| **조회 빈도** | WHERE, JOIN, ORDER BY, GROUP BY 절에 자주 등장하는 컬럼 |
| **카디널리티** | 중복이 적은 고유값일수록 효율적 |
| **추출 비율** | 전체의 20~25% 이하인 경우에만 효과적 |
| **업데이트 빈도** | 갱신이 자주 일어나는 컬럼에는 불리함 |
| **복합 인덱스 순서** | WHERE 절에서 자주 사용되는 순으로 설계 |
| **커버링 인덱스** | 인덱스만으로 SELECT가 가능하면 테이블 접근 생략 가능 |

---

## 📚 예시: 세컨더리 인덱스 설계 기준

- 조건절에 자주 등장하고
- 중복도가 낮고
- 정렬/그룹핑에 사용되며
- 변경이 적은 컬럼

~~~sql
-- 예: 사용자 활동 로그 테이블
CREATE INDEX idx_user_log ON user_log (user_id, created_at);
~~~

---

## 인덱스 → 쿼리 성능 최적화 전략

- **실행 계획 분석 (`EXPLAIN`)**
- **인덱스 힌트 사용 (`USE INDEX`, `FORCE INDEX`)**
- **파티셔닝, 샤딩, 분산 인덱싱**
- **인덱스가 무시되는 조건 분석**
  - OR 절, 함수 사용, 타입 미스매치, 불필요한 CAST 등

---
