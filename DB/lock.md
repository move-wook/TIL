# 🔐 공유 락과 배타 락 정리

## 1. 🔍 개념적 시야: 트랜잭션의 동시성 제어

멀티 트랜잭션 환경에서 데이터의 **일관성(Consistency)**과 **격리성(Isolation)**을 보장하기 위해 **락(Lock)**이 사용된다.  
대표적인 락 종류는 다음 두 가지다:

- **공유 락 (Shared Lock, S-lock)**: 읽기 전용
- **배타 락 (Exclusive Lock, X-lock)**: 쓰기 전용

---

## 2. 📌 공유 락 (Shared Lock)

- **목적**: 데이터를 읽기 위해 사용
- **호환성**: 다른 트랜잭션도 동시에 공유 락 획득 가능
- **제한**: 배타 락과는 **호환되지 않음**
- **대표 사용**: `SELECT ... FOR SHARE`

### 예시
트랜잭션 A, B가 동시에 고객 정보를 조회할 때 → 두 트랜잭션 모두 공유 락을 획득 가능

---

## 3. 📌 배타 락 (Exclusive Lock)

- **목적**: 데이터를 변경하기 위해 사용
- **호환성**: 어떤 다른 락과도 **호환되지 않음**
- **권한**: 읽기 + 쓰기 모두 가능 (단독 접근)
- **대표 사용**: `UPDATE`, `DELETE`, `INSERT`

### 예시
트랜잭션 C가 계좌 잔액을 수정할 때 → 배타 락을 획득하면 다른 트랜잭션은 접근 불가

---

## 4. 🧾 비교표

| 구분         | 공유 락 (S-lock)        | 배타 락 (X-lock)         |
|--------------|--------------------------|---------------------------|
| 사용 목적    | 읽기 전용                | 쓰기 (읽기 포함)          |
| 동시 허용    | 공유 락끼리는 허용       | 단독으로만 허용           |
| 충돌 여부    | 배타 락과 충돌           | 모든 락과 충돌            |
| 대표 SQL     | `SELECT ... FOR SHARE`   | `UPDATE`, `DELETE` 등     |

---

## 5. 📈 락 루프 흐름

1. 트랜잭션 시작
2. 데이터 접근 시 락 획득 시도
3. 락 충돌 여부 확인
4. 충돌 시 대기 or 타임아웃
5. 락 해제 후 다음 트랜잭션 진행

---

## 6. 🎯 기준 형성: 왜 락을 쓰는가?

- 데이터의 무결성과 일관성 유지
- 동시성 환경에서 충돌 방지
- `ACID`의 **Isolation** 보장을 위한 수단

---

## 7. 🔁 시야 전이: 격리 수준과의 연결

락의 유지 범위는 **트랜잭션 격리 수준**에 따라 달라진다:

| 격리 수준           | 락 유지 범위                     |
|----------------------|----------------------------------|
| Read Uncommitted     | 락 없음 또는 최소화             |
| Read Committed       | 읽을 때만 잠깐 공유 락 유지     |
| Repeatable Read      | 트랜잭션 종료 시까지 공유 락 유지 |
| Serializable         | 범위 락 포함, 공유/배타 모두 강화 |

---

## 🧠 다음 시야 제안

- `MVCC`에서는 락 없이 어떻게 동시성을 보장할까?
- 락 기반 시스템에서 **데드락**은 어떻게 발생하며, 어떻게 해결할까?
- 락 대기 분석 (`Lock Wait`, `Wait-For Graph`)은 어떻게 설계할 수 있을까?
